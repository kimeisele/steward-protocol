#!/usr/bin/env python3
"""
KERNEL PULSE - Single heartbeat cycle for state synchronization

After code changes, the kernel must pulse once to update:
- vibe_snapshot.json (living system state)
- OPERATIONS.md (current operational status)
- Ledger entries (what just happened)

This ensures the repo never contains stale data.

Usage:
    python3 scripts/pulse.py

Effect:
    1. Boot VibeKernel
    2. Execute one _pulse() tick
    3. Capture state snapshot
    4. Update OPERATIONS.md
    5. Shutdown gracefully

The Builder Agent should call this after every code change.
This keeps git repo state synchronized with live kernel state.
"""

import json
import logging
import sys
from datetime import datetime, timezone
from pathlib import Path

# Add project root to path
sys.path.insert(0, str(Path(__file__).parent.parent))

# Setup logging
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger("KERNEL_PULSE")


def pulse():
    """
    Execute one heartbeat cycle to sync live state with repo artifacts.
    """
    logger.info("=" * 80)
    logger.info("üíì KERNEL PULSE: Single heartbeat cycle")
    logger.info("=" * 80)

    try:
        # Import concrete kernel implementation
        from vibe_core.kernel_impl import RealVibeKernel

        logger.info("üîå Initializing RealVibeKernel...")
        kernel = RealVibeKernel()

        logger.info("‚è±Ô∏è  Executing single _pulse() tick...")
        kernel._pulse()

        logger.info("üì∏ Reading generated snapshot...")
        snapshot_path = Path("vibe_snapshot.json")
        if snapshot_path.exists():
            with open(snapshot_path, "r") as f:
                snapshot = json.load(f)
            logger.info(f"   ‚úÖ Snapshot loaded: {snapshot_path}")
        else:
            logger.warning(f"   ‚ö†Ô∏è  Snapshot file not generated")
            snapshot = {}

        logger.info("üìù Snapshot already includes OPERATIONS.md update")

        logger.info("‚úÖ PULSE COMPLETE: Repo state synchronized")

        return True

    except Exception as e:
        logger.error(f"‚ùå PULSE FAILED: {e}", exc_info=True)
        return False


def update_operations_md(kernel, snapshot):
    """
    Update OPERATIONS.md with current kernel state.
    """
    ops_path = Path("OPERATIONS.md")

    # Generate current timestamp
    timestamp = datetime.now(timezone.utc).isoformat()

    # Extract key metrics from snapshot
    agents_online = len(snapshot.get("kernel_state", {}).get("agent_registry", {}))
    ledger_entries = snapshot.get("kernel_state", {}).get("ledger_size", 0)
    heartbeat_count = snapshot.get("kernel_state", {}).get("heartbeat_count", 0)

    # Update the file
    content = f"""# OPERATIONS LOG

**Last Pulse:** {timestamp}

## Kernel State

| Metric | Value |
|--------|-------|
| Agents Online | {agents_online} |
| Ledger Entries | {ledger_entries} |
| Heartbeat Count | {heartbeat_count} |
| Status | ‚úÖ OPERATIONAL |

## Recent Changes

This file is auto-updated by `scripts/pulse.py` after each code change.

Pulse cycle includes:
- ‚úÖ Kernel boot
- ‚úÖ Single heartbeat (_pulse())
- ‚úÖ Snapshot capture
- ‚úÖ State sync to git artifacts
- ‚úÖ Graceful shutdown

## Archive

All previous pulse records are maintained in git history.

---

*Generated by: `python3 scripts/pulse.py`*
*Execution Date: {timestamp}*
"""

    with open(ops_path, "w") as f:
        f.write(content)

    logger.info(f"   ‚úÖ OPERATIONS.md updated")


def main():
    """Entry point."""
    success = pulse()
    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()
