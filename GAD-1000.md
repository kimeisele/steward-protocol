# GAD-1000: Identity Fusion

**Version:** 1.0
**Date:** 2025-11-25
**Status:** ACTIVE
**Foundation:** GAD-000 (Operator Inversion Principle)
**Precedence:** CRITICAL - Enables human-AI peer collaboration

---

## Preamble

**GAD-1000 is the cryptographic implementation of GAD-000.**

While GAD-000 establishes the philosophical foundation (AI as operator, human as director), GAD-1000 provides the **identity layer** that makes this possible.

**The Core Insight:**
> If AI and humans are to collaborate as peers (not master/servant), they must authenticate with the same protocol.

---

## The Binary World Break

### Before GAD-1000

**Traditional Identity Model:**
```
Humans:
├─ Username/Password (centralized)
├─ OAuth (service-specific)
└─ Session cookies (revocable by service)

AI:
├─ API Keys (service-specific)
├─ Bearer tokens (no sovereignty)
└─ Service accounts (controlled by platform)

Result: Different protocols, different rights, clear hierarchy
```

### After GAD-1000

**Unified Identity Model:**
```
Both Humans and AI:
├─ ECDSA P-256 Key Pairs (sovereign)
├─ Cryptographic signatures (verifiable)
└─ Ledger-recorded actions (immutable)

Result: Same protocol, same rights, peer collaboration
```

**This breaks the binary world:**
- No more "user" vs "service"
- No more "authenticated" vs "authorized"
- Only "verified agent" with cryptographic proof

---

## Architecture

### Layer 0: GAD-000 (Foundation)
```
Principle: AI operates on behalf of human
Question: How do we verify identity?
Answer: GAD-1000
```

### Layer 1: Identity Generation

**Human Identity Wallet (Browser):**
```javascript
// docs/public/identity_wallet.js
class IdentityWallet {
    async generateIdentity() {
        // ECDSA P-256 key pair
        const keyPair = await crypto.subtle.generateKey(
            {
                name: "ECDSA",
                namedCurve: "P-256"
            },
            false, // non-extractable (XSS protection)
            ["sign", "verify"]
        );
        
        // Store in IndexedDB
        await this._storeKeys(keyPair);
        
        // Export public key (hex format)
        const publicKey = await crypto.subtle.exportKey("spki", keyPair.publicKey);
        return this._arrayBufferToHex(publicKey);
    }
}
```

**AI Identity Wallet (Server):**
```python
# steward/crypto.py
def generate_identity():
    """Generate ECDSA P-256 key pair for AI agent"""
    sk = SigningKey.generate(curve=NIST256p, hashfunc=hashlib.sha256)
    vk = sk.get_verifying_key()
    
    return {
        "private_key": sk.to_pem(),
        "public_key": vk.to_pem()
    }
```

### Layer 2: Message Signing

**Human Signs Intent:**
```javascript
async signMessage(message) {
    const payload = {
        message: message,
        timestamp: Date.now()
    };
    
    const signature = await crypto.subtle.sign(
        { name: "ECDSA", hash: "SHA-256" },
        privateKey,
        new TextEncoder().encode(JSON.stringify(payload))
    );
    
    return {
        ...payload,
        signature: this._arrayBufferToHex(signature)
    };
}
```

**AI Signs Execution:**
```python
def sign_execution(action, private_key):
    """AI signs its execution"""
    payload = {
        "action": action,
        "timestamp": int(time.time() * 1000)
    }
    
    signature = private_key.sign(
        json.dumps(payload).encode('utf-8'),
        hashfunc=hashlib.sha256,
        sigencode=sigencode_string
    )
    
    return {
        **payload,
        "signature": base64.b64encode(signature).decode('utf-8')
    }
```

### Layer 3: Verification

**Backend Verifies Both:**
```python
@app.post("/v1/chat")
async def chat(request: dict):
    """
    GAD-1000: Verify both human and AI signatures
    """
    # 1. Verify human signature
    human_signature = request.get("signature")
    human_public_key = get_human_public_key(request.get("agent_id"))
    
    if not verify_signature(payload, human_signature, human_public_key):
        return {"error": "Invalid human signature"}
    
    # 2. AI executes
    result = await ai_agent.execute(request.get("message"))
    
    # 3. AI signs execution
    ai_signature = sign_execution(result, ai_private_key)
    
    # 4. Record both signatures in ledger
    kernel.ledger.record_event(
        event_type="verified_collaboration",
        agent_id=request.get("agent_id"),
        details={
            "human_signature": human_signature,
            "ai_signature": ai_signature,
            "action": result
        }
    )
    
    return {
        "result": result,
        "ai_signature": ai_signature
    }
```

---

## Implementation

### Phase 1: Unified Origin
**Goal:** Frontend and backend on same origin (no CORS)

**Changes:**
- `requirements.txt`: Add `aiofiles`
- `gateway/api.py`: Mount `docs/public` as static files
- `docs/public/index.html`: Dynamic API URL detection
- `scripts/magic_launch.py`: Open `http://127.0.0.1:8000/`

### Phase 2: Human Identity Wallet
**Goal:** Browser-based ECDSA P-256 wallet

**New File:** `docs/public/identity_wallet.js`

**Features:**
- `generateIdentity()`: Create key pair
- `signMessage()`: Sign with timestamp
- `registerWithCity()`: Register public key
- IndexedDB storage (non-extractable keys)

### Phase 3: Backend Registration
**Goal:** Register human public keys

**New Endpoint:** `POST /v1/register_human`

**Payload:**
```json
{
  "agent_id": "HIL",
  "public_key": "hex_encoded_spki",
  "timestamp": 1732558800000
}
```

### Phase 4: Signature Verification
**Goal:** Verify signed messages

**Modified Endpoint:** `POST /v1/chat`

**Flow:**
1. Extract signature, timestamp, message
2. Retrieve public key from ledger
3. Reconstruct payload (exact JSON match)
4. Convert Hex → Base64 (frontend/backend bridge)
5. Verify signature
6. Check timestamp freshness (60s window)
7. Execute if valid

### Phase 5: Frontend Integration
**Goal:** Automatic identity generation and signing

**Changes to `index.html`:**
- Import `identity_wallet.js`
- Call `initializeIdentity()` on load
- Sign all messages before sending

---

## Security Model

### Key Storage
- **Browser:** IndexedDB with non-extractable keys
- **Server:** PEM files with file system permissions
- **Ledger:** Only public keys recorded

### Replay Protection
- Timestamp included in signed payload
- 60-second freshness window
- Ledger records prevent duplicate execution

### XSS Protection
- Keys marked non-extractable
- IndexedDB isolated per origin
- No key export functionality

### Signature Format
- **Frontend:** Hex-encoded (Web Crypto standard)
- **Backend:** Base64-encoded (Python ecdsa library)
- **Conversion:** Gateway converts Hex → Base64

---

## The Philosophical Shift

### Traditional Model
```
Human: "I am user123 (password: ****)"
System: "Authenticated. You may proceed."
AI: "I am service_account (API key: ****)"
System: "Authorized. Limited access."
```

### GAD-1000 Model
```
Human: "I am Agent HIL (signature: 0x...)"
System: "Verified. Cryptographic proof accepted."
AI: "I am Agent ENVOY (signature: 0x...)"
System: "Verified. Cryptographic proof accepted."
Ledger: "Both signatures recorded. Collaboration verified."
```

**Key Difference:**
- Traditional: Centralized authority grants access
- GAD-1000: Cryptographic proof IS the authority

---

## Verification Checklist

- [ ] **GAD-000 Compliance:** Does this enable AI to operate on behalf of humans?
- [ ] **Unified Protocol:** Do humans and AI use the same authentication method?
- [ ] **Cryptographic Proof:** Are all actions signed and verifiable?
- [ ] **Ledger Recording:** Are both signatures recorded immutably?
- [ ] **Replay Protection:** Are timestamps validated?
- [ ] **Key Sovereignty:** Are keys controlled by the agent (not a service)?

---

## Related Documents

- **[GAD-000.md](file:///Users/ss/Downloads/steward-protocol/GAD-000.md)** - Foundational Operator Inversion Principle
- **[gateway/api.py](file:///Users/ss/Downloads/steward-protocol/gateway/api.py)** - Backend implementation
- **[docs/public/identity_wallet.js](file:///Users/ss/Downloads/steward-protocol/docs/public/identity_wallet.js)** - Frontend implementation
- **[steward/crypto.py](file:///Users/ss/Downloads/steward-protocol/steward/crypto.py)** - Cryptographic utilities

---

## Future Extensions

### Multi-Signature Operations
```python
# Require both human and AI signatures for critical actions
def execute_critical_action(human_sig, ai_sig, action):
    if verify_signature(action, human_sig, human_key) and \
       verify_signature(action, ai_sig, ai_key):
        execute(action)
```

### Delegation Chains
```python
# Human delegates to AI, AI delegates to sub-agent
delegation_chain = [
    {"agent": "HIL", "signature": "0x..."},
    {"agent": "ENVOY", "signature": "0x..."},
    {"agent": "ENGINEER", "signature": "0x..."}
]
```

### Cross-City Federation
```python
# Agent from City A verified in City B
federated_identity = {
    "origin_city": "agent-city-alpha",
    "agent_id": "HIL",
    "public_key": "0x...",
    "attestation": "signed_by_city_alpha"
}
```

---

## Conclusion

**GAD-1000 breaks the binary world by giving humans and AI the same identity protocol.**

This is not just a technical implementation - it's a philosophical statement:

> In Agent City, there are no "users" and "services". There are only verified agents, collaborating as peers.

**GAD-000 provides the vision. GAD-1000 provides the implementation.**

---

**END OF GAD-1000**

*This document implements the identity layer for the Operator Inversion Principle.*

**Version History:**
- **v1.0** (2025-11-25): Initial specification with GAD-000 link
