#!/usr/bin/env python3
"""
AGENT CITY LAUNCHER - The Envoy Interface (Kernel-Integrated Version)

This script launches the Universal Operator interface for Agent City.
It boots the real VibeOS kernel, registers all agents, and wires the Envoy as the
operational hub.

This is the final wiring: User Input â†’ Task â†’ Kernel â†’ Envoy â†’ CityControlTool â†’ Agents

Usage:
  ./bin/agent-city                    # Start interactive session with kernel
  ./bin/agent-city --status           # Quick kernel status check
  ./bin/agent-city --kernel-status    # Detailed kernel state
  ./bin/agent-city --help             # Show help

ARCH CHANGE:
- OLD: bin/agent-city â†’ CityControlTool (DIRECT mode, no kernel)
- NEW: bin/agent-city â†’ RealVibeKernel â†’ Envoy â†’ CityControlTool (KERNEL mode)

The brain is now connected to the heart.
"""

import sys
import os
from pathlib import Path
import argparse
import json
import time
import logging

# Add project root to path
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(levelname)s [%(name)s] %(message)s'
)
logger = logging.getLogger("AGENT_CITY_LAUNCHER")

# Import VibeOS kernel and agents
from vibe_core.kernel_impl import RealVibeKernel
from vibe_core.scheduling import Task

# Import all agent cartridges
from herald.cartridge_main import HeraldCartridge
from civic.cartridge_main import CivicCartridge
from forum.cartridge_main import ForumCartridge
from science.cartridge_main import ScientistCartridge
from envoy.cartridge_main import EnvoyCartridge

# ANSI colors for terminal output
class Colors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    END = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'


def print_banner():
    """Print the Agent City banner."""
    banner = f"""
{Colors.CYAN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                    â•‘
â•‘                   ğŸ‘ï¸  THE ENVOY - Agent City Interface            â•‘
â•‘                                                                    â•‘
â•‘        "The bridge between Human Intent and Agent Execution"      â•‘
â•‘                                                                    â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•{Colors.END}
"""
    print(banner)


def load_system_prompt() -> str:
    """Load the Envoy system prompt."""
    prompt_path = project_root / "prompts" / "envoy.md"

    if not prompt_path.exists():
        logger.warning(f"Envoy system prompt not found at {prompt_path}")
        return ""

    return prompt_path.read_text()


def load_policies() -> str:
    """Load POLICIES.md for context."""
    policies_path = project_root / "POLICIES.md"

    if not policies_path.exists():
        logger.warning("POLICIES.md not found")
        return ""

    return policies_path.read_text()


def boot_kernel() -> RealVibeKernel:
    """
    Boot the real VibeOS kernel and register all agents.

    Returns:
        RealVibeKernel: The booted kernel with all agents registered
    """
    logger.info("=" * 70)
    logger.info("âš™ï¸  KERNEL BOOT SEQUENCE INITIATED")
    logger.info("=" * 70)

    # Create kernel
    kernel = RealVibeKernel()
    logger.info("âœ… Kernel instance created")

    # Create and register agents
    agents_to_register = [
        ("herald", HeraldCartridge()),
        ("civic", CivicCartridge()),
        ("forum", ForumCartridge()),
        ("science", ScientistCartridge()),
        ("envoy", EnvoyCartridge()),
    ]

    for agent_id, agent_instance in agents_to_register:
        try:
            kernel.register_agent(agent_instance)
            logger.info(f"âœ… Agent registered: {agent_id}")
        except Exception as e:
            logger.error(f"âŒ Failed to register {agent_id}: {e}")
            raise

    # Boot kernel (register manifests and start)
    kernel.boot()

    return kernel


def quick_status(kernel: RealVibeKernel = None):
    """
    Run a quick status check and exit.

    Args:
        kernel: Optional kernel instance. If not provided, will boot a new one.
    """
    print_banner()
    print(f"\n{Colors.BOLD}ğŸ“Š KERNEL STATUS{Colors.END}\n")

    # Boot if needed
    if not kernel:
        try:
            kernel = boot_kernel()
        except Exception as e:
            print(f"{Colors.RED}âŒ Failed to boot kernel: {e}{Colors.END}")
            return

    # Get kernel status
    status = kernel.get_status()

    print(f"{Colors.CYAN}âš™ï¸  Kernel Status:{Colors.END} {status.get('status', 'Unknown')}")
    print(f"{Colors.CYAN}ğŸ¤– Agents Registered:{Colors.END} {status.get('agents_registered', 0)}")
    print(f"{Colors.CYAN}ğŸ“‹ Manifests:{Colors.END} {status.get('manifests', 0)}")
    print(f"{Colors.CYAN}ğŸ“ Ledger Events:{Colors.END} {status.get('ledger_events', 0)}")

    scheduler = status.get('scheduler', {})
    print(f"{Colors.CYAN}ğŸ“¨ Scheduler:{Colors.END}")
    print(f"{Colors.CYAN}   â”œâ”€ Queue Length: {scheduler.get('queue_length', 0)}{Colors.END}")
    print(f"{Colors.CYAN}   â””â”€ Completed: {scheduler.get('completed', 0)}{Colors.END}")

    # List agents
    agents = list(kernel.agent_registry.keys())
    if agents:
        print(f"\n{Colors.BOLD}ğŸ¤– REGISTERED AGENTS:{Colors.END}")
        for agent_id in agents:
            manifest = kernel.get_agent_manifest(agent_id)
            if manifest:
                print(f"   â€¢ {agent_id}: {manifest.description}")

    print(f"\n{Colors.GREEN}âœ… KERNEL OPERATIONAL{Colors.END}\n")


def interactive_mode():
    """
    Start interactive REPL session with the Envoy.

    This is the main user interface. All commands are converted to Tasks
    and sent to the Envoy through the kernel scheduler.

    Flow: User Input â†’ Task â†’ Kernel Scheduler â†’ Envoy.process() â†’ CityControlTool â†’ Agents
    """
    print_banner()

    # Load context
    system_prompt = load_system_prompt()
    policies = load_policies()

    # Boot the kernel
    print(f"\n{Colors.BOLD}ğŸš€ Starting kernel boot...{Colors.END}\n")
    try:
        kernel = boot_kernel()
    except Exception as e:
        print(f"{Colors.RED}âŒ Failed to boot kernel: {e}{Colors.END}")
        import traceback
        traceback.print_exc()
        return

    # Get the Envoy agent
    envoy = kernel.agent_registry.get("envoy")
    if not envoy:
        print(f"{Colors.RED}âŒ Envoy not found in kernel registry{Colors.END}")
        return

    # Startup sequence
    print(f"\n{Colors.GREEN}âœ… THE ENVOY - Brain Connected to Heart{Colors.END}")
    print(f"{Colors.CYAN}ğŸ“œ System Prompt Loaded: prompts/envoy.md{Colors.END}")
    print(f"{Colors.CYAN}ğŸ“‹ Policies Loaded: POLICIES.md{Colors.END}")
    print(f"{Colors.CYAN}ğŸ§ â¤ï¸ Envoy: Connected to RealVibeKernel{Colors.END}")
    print(f"{Colors.CYAN}ğŸ¤– Agents: {len(kernel.agent_registry)} registered{Colors.END}\n")

    # Show kernel status
    print(f"{Colors.BOLD}ğŸ“Š Kernel Status:{Colors.END}")
    kernel_status = kernel.get_status()
    print(f"   Status: {kernel_status.get('status')}")
    print(f"   Agents: {kernel_status.get('agents_registered')}")
    print(f"   Manifests: {kernel_status.get('manifests')}\n")

    # Show available commands
    print(f"{Colors.BOLD}Available Commands:{Colors.END}")
    print(f"   {Colors.CYAN}status{Colors.END}              - Get city status")
    print(f"   {Colors.CYAN}proposals{Colors.END}           - List governance proposals")
    print(f"   {Colors.CYAN}credits <agent>{Colors.END}     - Check agent credits")
    print(f"   {Colors.CYAN}vote <id> <choice>{Colors.END}  - Vote on proposal (YES/NO/ABSTAIN)")
    print(f"   {Colors.CYAN}execute <id>{Colors.END}        - Execute approved proposal")
    print(f"   {Colors.CYAN}trigger <agent> <action>{Colors.END} - Trigger agent action")
    print(f"   {Colors.CYAN}kernel-status{Colors.END}       - Show kernel internal state")
    print(f"   {Colors.CYAN}kernel-ledger{Colors.END}       - Dump ledger events")
    print(f"   {Colors.CYAN}help{Colors.END}                - Show this help")
    print(f"   {Colors.CYAN}exit{Colors.END}                - Exit\n")

    print(f"{Colors.BOLD}How can I help?{Colors.END}\n")

    task_counter = 0

    # REPL loop
    while True:
        try:
            user_input = input(f"{Colors.GREEN}>{Colors.END} ").strip()

            if not user_input:
                continue

            # Parse command
            parts = user_input.split()
            command = parts[0].lower()
            args = parts[1:]

            # Handle commands
            if command in ['exit', 'quit', 'q']:
                print(f"\n{Colors.CYAN}ğŸ‘‹ The Envoy disconnects. Om Tat Sat.{Colors.END}\n")
                break

            elif command == 'help':
                print(f"\n{Colors.BOLD}Available Commands:{Colors.END}")
                print(f"   status              - Get city status")
                print(f"   proposals           - List governance proposals")
                print(f"   credits <agent>     - Check agent credits")
                print(f"   vote <id> <choice>  - Vote on proposal")
                print(f"   execute <id>        - Execute approved proposal")
                print(f"   trigger <agent> <action> - Trigger agent action")
                print(f"   kernel-status       - Show kernel state")
                print(f"   kernel-ledger       - Dump ledger")
                print(f"   help                - Show this help")
                print(f"   exit                - Exit\n")

            elif command == 'kernel-status':
                status = kernel.get_status()
                print(json.dumps(status, indent=2))

            elif command == 'kernel-ledger':
                ledger = kernel.dump_ledger()
                print(json.dumps(ledger, indent=2))

            else:
                # Route all other commands through the Envoy via kernel
                # Convert user input to a task for the Envoy
                task_counter += 1
                task = Task(
                    agent_id="envoy",
                    payload={
                        "command": command,
                        "args": _parse_args(command, args)
                    }
                )

                # Submit task to kernel scheduler
                task_id = kernel.submit_task(task)
                logger.info(f"ğŸ“¤ Task submitted to kernel: {task_id} for command '{command}'")

                # Process the task immediately (single-threaded tick)
                kernel.tick()

                # Retrieve result from ledger
                result = kernel.get_task_result(task_id)

                if result:
                    if result.get('status') == 'COMPLETED':
                        output = result.get('output_result')
                        if isinstance(output, dict):
                            print(json.dumps(output, indent=2))
                        else:
                            print(output)
                    elif result.get('status') == 'FAILED':
                        print(f"{Colors.RED}âŒ Error: {result.get('error')}{Colors.END}")
                else:
                    print(f"{Colors.YELLOW}âš ï¸  Task result not found{Colors.END}")

            print()  # Empty line for readability

        except KeyboardInterrupt:
            print(f"\n\n{Colors.CYAN}ğŸ‘‹ The Envoy disconnects. Om Tat Sat.{Colors.END}\n")
            break
        except Exception as e:
            logger.exception(f"Error processing command: {e}")
            print(f"{Colors.RED}âŒ Error: {e}{Colors.END}")


def _parse_args(command: str, args: list) -> dict:
    """
    Parse command-line arguments into a dict for the Envoy task payload.

    Args:
        command: The command name
        args: List of argument strings

    Returns:
        dict: Parsed arguments for the command
    """
    if command == 'status':
        return {}

    elif command == 'proposals':
        return {
            'status': args[0] if args else 'OPEN'
        }

    elif command == 'credits':
        return {
            'agent_name': args[0] if args else None
        }

    elif command == 'vote':
        return {
            'proposal_id': args[0] if len(args) > 0 else None,
            'choice': args[1] if len(args) > 1 else None,
            'voter': 'operator'
        }

    elif command == 'execute':
        return {
            'proposal_id': args[0] if args else None
        }

    elif command == 'trigger':
        return {
            'agent_name': args[0] if len(args) > 0 else None,
            'action': args[1] if len(args) > 1 else None,
            'kwargs': {}
        }

    else:
        return {}


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Agent City Launcher - Kernel-Integrated Version",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  ./bin/agent-city                    # Start interactive session with kernel
  ./bin/agent-city --status           # Quick kernel status check
  ./bin/agent-city --kernel-status    # Detailed kernel state

ARCHITECTURE:
  User Input â†’ Task â†’ RealVibeKernel â†’ Envoy.process() â†’ CityControlTool â†’ Agents

The Envoy's brain is now wired to the Kernel's heart.
        """
    )

    parser.add_argument(
        '--status',
        action='store_true',
        help='Show quick kernel status and exit'
    )

    parser.add_argument(
        '--kernel-status',
        action='store_true',
        help='Show detailed kernel internal state'
    )

    parser.add_argument(
        '--version',
        action='version',
        version='Agent City Launcher v2.0.0 (Kernel-Integrated)'
    )

    args = parser.parse_args()

    # Set environment variables for VibeOS integration
    os.environ['VIBE_SYSTEM_PROMPT'] = str(project_root / "prompts" / "envoy.md")
    os.environ['AGENT_CITY_ROOT'] = str(project_root)

    # Route to appropriate mode
    if args.status:
        quick_status()
    elif args.kernel_status:
        kernel = boot_kernel()
        status = kernel.get_status()
        print("\n" + "=" * 70)
        print("KERNEL INTERNAL STATE")
        print("=" * 70)
        print(json.dumps(status, indent=2))
        print("\nLedger Events:")
        ledger = kernel.dump_ledger()
        print(json.dumps(ledger, indent=2))
    else:
        interactive_mode()


if __name__ == "__main__":
    main()
